01-01-2021
-- basic file structure
-- models, inheritance only
-- migration files, first pass, no migration yet

01-04-2021
-- coded views/characters
-- copied to GitHub

01-05-2021
-- Added concerns/sluggy and included in character and novel models and views
-- Hopefully updated all relevant files to require concerns/sluggy
-- coded /novels/index, /new, /show views
-- coded character and novel edit forms
-- migrated databases, no major problems
-- created and migrated seed data 
-- did some minor bug hunting (bug hunt 1)
-- BUG SMASH (bug hunt 2): fixed the controller reading issue (note: don't forget to 'use' all your controllers in config.ru)

01-08-2021
-- added user model, users and sessions controllers, user views
-- deleted sluggy, alas poor sluggy. next time maybe think about broader methods to inherit before coding the databases
-- minor styling
-- created main index landing page
-- added helpers to appcont: 

TO DO:
-- NOVELS:
-- associate novels to users (db column add, belongs_to association in novel model, has_many association in user model)
-- make sure novels are only accessible to logged in users
-- add column for synopsis to novels (datatype is text)
-- style novel show page, index page w/synopsis?, create and edit pages
-- DON'T FORGET edit/delete links should be at the bottom of the novel page
-- patch code for novels 
-- before '/novels/*' do verify_me end
-- validates :stuff, :user_id, presence: true
-- post route for new novels @novel = current_user.novels.build(params go here) followed by if @novel.save
-- in the edit view: IF current_user.id == @novel.user_id THEN render the erb ELSE flash message no touchy and redirect to index
(can probably also add this to create pages)
-- CHARACTERS 
-- route for character show page: 'novels/novel-slug/characters/char-slug' (params[:novel-slug], params[:char_slug])
-- (this may be a bit complicated but I have faith in you)
-- style character show page to show the character name, novel, and associated tropes w/descriptions
-- edit/delete links should be at the bottom of the character page
-- patch code for characters
-- (your erb on get /character/slug is weird, it should be a simple show erb, fix it)
-- @novel = current_user.novels.find(params[:novel]), @character = @novel.characters.find(params[:id])
-- TROPES 
-- add a description column (datatype is text)


-- make flash messages
-- make tests
-- run tests
-- bug hunt

TO EXPAND:
-- make genre a separate model, albeit a simple one: a novel has_many genres. Then add a show page to search novels by genre.
-- maybe add a public index page so people can view other people's novels without editing them?
-- in which case you'll need a button and a separate array for public novels so users can toggle it public/private
-- maybe add an active/inactive boolean column to the novel thing

BUGS: 

NOTES: 
-- slugging and unslugging: artists and modules lab, Intro to Modules reading
-- login >> user index of novel projects >> novel: genre, word count, characters, edit option (list of tropes?) >> character >> edit option, list of tropes
-- authentication vs authorization 
-- update method will save, and thus will also trigger validation (making sure all fields have data)
-- validates method in the model also has an 'on: :create' so you can only validate at a certain point; this doesn't apply here.
-- erbs do not render http requests, just pull files

@user = current_user 
if @user.id == @novel.user_id 
THEN show the novels 
ELSE show nothing

PROJECT GOALS
-- Build an M(odel)V(iews)C(ontroller) Sinatra application. DONE
-- Use ActiveRecord with Sinatra. DONE
-- Use multiple models. DONE
-- Use at least one has_many relationship on a User model and one belongs_to relationship on another model. DONE
-- Must have user accounts - users must be able to sign up, sign in, and sign out. DONEish
-- Validate uniqueness of user login attribute (username or email). DONE
-- Once logged in, a user must have the ability to create, read, update and destroy the resource that belongs_to user.
-- Ensure that users can edit and delete only their own resources - not resources created by other users.
-- Validate user input so bad data cannot be persisted to the database.
-- BONUS: Display validation failures to user with error messages. (This is an optional feature, challenge yourself and give it a shot!)

